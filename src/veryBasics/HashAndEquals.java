package veryBasics;

import java.util.HashSet;
import java.util.Set;

//1. "=="  tests if the reference the same object
//2. obj_1.equals(obj_2)  override it to compare 2 object based on custom identities/fields/atrtibutes
//3. must ovverride hashcode() , if you ovverode the equals(), to prevent malfunctions, with collections mostly maps
//4. hashcode if not overridden return the address of the object. Simply put, hashCode() returns an integer value, 
//generated by a hashing algorithm. Objects that are equal (according to their equals()) 
//must return the same hash code. It's not required for different objects to return different hash codes.

class Employee {
	int id;
	String name;
	String company;
	
	public Employee(int id, String name, String company) {
		super();
		this.id = id;
		this.name = name;
		this.company = company;
	}

	@Override
	public String toString() {
		return "Employee [id=" + id + ", name=" + name + ", company=" + company + "]";
	}	
}

class EmployeeOnlyEquals {
	int id;
	String name;
	String company;
	
	public EmployeeOnlyEquals(int id, String name, String company) {
		super();
		this.id = id;
		this.name = name;
		this.company = company;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		EmployeeOnlyEquals other = (EmployeeOnlyEquals) obj;
		if (company == null) {
			if (other.company != null)
				return false;
		} else if (!company.equals(other.company))
			return false;
		if (id != other.id)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}



	@Override
	public String toString() {
		return "Employee [id=" + id + ", name=" + name + ", company=" + company + "]";
	}	
}


class EmployeeFull {
	int id;
	String name;
	String company;
	
	public EmployeeFull(int id, String name, String company) {
		super();
		this.id = id;
		this.name = name;
		this.company = company;
	}

	
	
	@Override
	public int hashCode() {															// so COMPUTER knows that they are the same, or they are different!
		final int prime = 31;
		int result = 1;
		result = prime * result + ((company == null) ? 0 : company.hashCode());
		result = prime * result + id;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}



	@Override
	public boolean equals(Object obj) {												// so WE know that they are the same, or they are different!
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		EmployeeFull other = (EmployeeFull) obj;
		if (company == null) {
			if (other.company != null)
				return false;
		} else if (!company.equals(other.company))
			return false;
		if (id != other.id)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}



	@Override
	public String toString() {
		return "Employee [id=" + id + ", name=" + name + ", company=" + company + "]";
	}	
}


public class HashAndEquals {

	public static void main(String[] args) {
		
// 1. case: equals no override, create 2 object with the same fields, so they are "equals" but for the 
		// system they are 2 different object, on 2 different memory address
		
		Employee emp_1 = new Employee(101, "Adam", "Bigyo Kft");
		Employee emp_2 = new Employee(101, "Adam", "Bigyo Kft");
		
		System.out.println(emp_1.hashCode() + " | " + emp_2.hashCode());			// auto generated hascode, based on memory address ?!
		System.out.println(emp_1.equals(emp_2)); 									// false mert address alapjan hasonlitja ossze
	
		Set<Employee> employees = new HashSet<Employee>();
		
		employees.add(emp_1);
		employees.add(emp_2);
		
		employees.forEach(System.out::println);										// based on their hasCode they are different... but they should be the same
					
		
// 2. case: only equals are overridden, expect to be they are different by equals when they added to a hasmap
//		but they will be the same when get from the hasmap based on hashcode ?? ore the other way around, but it should malfunction
	
		
		EmployeeOnlyEquals emp_oe_1 = new EmployeeOnlyEquals(101, "Adam", "Bigyo Kft");
		EmployeeOnlyEquals emp_oe_2 = new EmployeeOnlyEquals(101, "Adam", "Bigyo Kft");
		
		System.out.println(emp_oe_1.hashCode() + " | " + emp_oe_2.hashCode());			// still different! auto generated hascode, based on memory address ?!
		System.out.println(emp_oe_1.equals(emp_oe_2)); 									// true, beacuse overridden
	
		Set<EmployeeOnlyEquals> employees_oe = new HashSet<EmployeeOnlyEquals>();
		
		employees_oe.add(emp_oe_1);
		employees_oe.add(emp_oe_2);
		
		employees_oe.forEach(System.out::println);										// even if they are equal, differnet hascode... treated as they were different object
	
		
// 3. case override hascode too, so the system also knows that when they are equals by comparing, they produce the same hascode too
		
		EmployeeFull emp_full_1 = new EmployeeFull(101, "Adam", "Bigyo Kft");
		EmployeeFull emp_full_2 = new EmployeeFull(101, "Adam", "Bigyo Kft");
		
		System.out.println(emp_full_1.hashCode() + " | " + emp_full_2.hashCode());			// same code generated so also the computer know they are the same
		System.out.println(emp_full_1.equals(emp_full_2)); 									// true, beacuse overridden
	
		Set<EmployeeFull> employees_full = new HashSet<EmployeeFull>();
		
		employees_full.add(emp_full_1);
		employees_full.add(emp_full_1);
		
		employees_full.forEach(System.out::println);
		
	}

}























